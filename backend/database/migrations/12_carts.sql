-- =============================================
-- 12_carts.sql
-- Shopping Cart System
-- Supports both authenticated and guest users (via session_id)
-- =============================================

CREATE TABLE IF NOT EXISTS public.carts (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    
    -- Owner Link (At least one must be present, usually)
    user_id UUID REFERENCES auth.users(id),
    session_id TEXT, -- For guest users (UUID string generated by client)
    
    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,

    -- Constraints: Ensure we don't have dupes for same user/session
    CONSTRAINT unique_user_cart UNIQUE (user_id),
    CONSTRAINT unique_session_cart UNIQUE (session_id)
);

CREATE TABLE IF NOT EXISTS public.cart_items (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    cart_id UUID REFERENCES public.carts(id) ON DELETE CASCADE,
    product_id UUID REFERENCES public.products(id) ON DELETE CASCADE,
    
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,

    -- Prevent duplicate rows for same product in same cart
    CONSTRAINT unique_cart_item UNIQUE (cart_id, product_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_carts_user ON public.carts(user_id);
CREATE INDEX IF NOT EXISTS idx_carts_session ON public.carts(session_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_cart ON public.cart_items(cart_id);

-- RLS: Carts
ALTER TABLE public.carts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;

-- Policies for Carts
-- 1. Users can view/edit their own cart
CREATE POLICY "Users can manage own cart" 
    ON public.carts FOR ALL 
    USING (auth.uid() = user_id);

-- 2. Guests can manage cart with matching session_id
-- Note: Supabase RLS with anonymous sessions is tricky. 
-- For simplicity in this hybrid app, we often allow public insert but restrictive select/update.
-- OR we rely on backend logic since we have a Node backend proxying these requests mostly.
-- IF connecting directly from frontend, we need `anon` access.
CREATE POLICY "Public can create carts" 
    ON public.carts FOR INSERT 
    WITH CHECK (true);

CREATE POLICY "Access by session_id" 
    ON public.carts FOR ALL 
    USING (session_id = current_setting('request.headers')::json->>'x-session-id');


-- Policies for Cart Items
-- Inherit from Cart
CREATE POLICY "Inherit cart access for items" 
    ON public.cart_items FOR ALL 
    USING (EXISTS (
        SELECT 1 FROM public.carts 
        WHERE id = cart_items.cart_id 
        AND (
            (auth.uid() = user_id) OR 
            (session_id = current_setting('request.headers')::json->>'x-session-id') OR
            (user_id IS NULL AND session_id IS NOT NULL) -- Fallback for backend simple queries
        )
    ));

-- Allow backend service role (full access) is implicit.
